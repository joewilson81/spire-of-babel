#!/usr/bin/env node

'use strict';

const fs = require('fs');
const path = require('path');

const chalk = require('chalk');

const spire = require('../lib/spire-of-babel');
const utils = require('../lib/utils');

const pkg = require('../package');

/**
* Displays help to stdout.
*/

const displayHelp = () => {

    process.stdout.write(`
${chalk.blue(' Usage:')} spire-of-babel <path> [options]

 Options:

${chalk.yellow('  -h, --help')}         Display this help message.
${chalk.yellow('  -v, --version')}      Display the current installed version.
${chalk.yellow('  -b, --bundle')}       Use browserify bundler.
${chalk.yellow('  -m, --minify')}       Minify output.
${chalk.yellow('  -d, --dir')}          Directory to run linter on.
${chalk.yellow('  -o, --output')}       Path to save transformed file to. Defaults to stdout.
${chalk.yellow('  -w, --watch')}        File path to watch for changes. Example: ./test/**/*.jsx
${chalk.yellow('  -l, --lint')}         Lint files before transpiling.
${chalk.yellow('  -s, --sourcemap')}    Generate sourcemap.

`);

};

/**
* Transforms input based on options passed to the command and outputs to either stdout or file.
*/

const transform = (input, options) => spire.transformFile(input, options).then(result => {

    if (options.output) {

        fs.writeFile(options.output, result.code, 'utf8');

        if (options.sourcemap) {

            fs.writeFile(`${options.output}.map`, result.map, 'utf8');

        }

    } else {

        process.stdout.write(result.code);

    }

});

/**
* Lints input based on options passed to the command.
*/

const lint = options => utils.findESLintConfigFile(process.cwd()).then(configFile =>

    spire.lintFile(options.dir, configFile)

);

/**
* Lints and transforms input based on options passed to the command.
*/

const lintAndTransform = (input, options) => {

    if (options.lint) {

        lint(options).then(() => transform(input, options))
            .catch(err => {

                process.stderr.write(`${err}\n`);

            });

    } else {

        transform(input, options)
            .catch(err => {

                process.stderr.write(`${err}\n`);

            });

    }

};

let input = null;

const options = {
    'bundle': false,
    'dir': null,
    'lint': false,
    'minify': false,
    'output': null,
    'sourcemap': false,
    'watch': null
};

const PROCESS_CMD_LINE_ARGS_LENGTH = 2;

const args = process.argv.slice(PROCESS_CMD_LINE_ARGS_LENGTH);

while (args.length) {

    const currentArg = args.shift();

    if (/^(?!\-).*/.test(currentArg)) {

        input = currentArg;

    } else {

        switch (currentArg) {

        case '-b':
        case '--bundle':

            options.bundle = true;

            break;

        case '-m':
        case '--minify':

            options.minify = true;

            break;

        case '-d':
        case '--dir':

            options.dir = args.shift();

            break;

        case '-o':
        case '--output':

            options.output = args.shift();

            break;

        case '-w':
        case '--watch':

            options.watch = utils.parseWatchPath(args.shift());

            break;

        case '-l':
        case '--lint':

            options.lint = true;

            break;

        case '-s':
        case '--sourcemap':

            options.sourcemap = true;

            break;

        case '-v':
        case '--version':

            process.stdout.write(`${pkg.version}\n`);
            process.exit();

            break;

        default:

            displayHelp();
            process.exit();

            break;

        }

    }

}

if (input) {

    if (!options.dir) {

        options.dir = path.resolve(path.dirname(input));

    }

    if (options.watch) {

        fs.watch(options.watch.directory, {
            'recursive': options.watch.recursive
        }, (event, filename) => {

            const file = `${options.watch.directory}/${filename}`;

            if (event === 'change' && file.match(new RegExp(`${options.watch.filename}$`))) {

                if (options.output) {

                    if (file === options.output) {

                        return false;

                    }

                    process.stdout.write(`
${chalk.gray('Change detected to: ')}${file}
${chalk.green('Transformed: ')}${input} -> ${options.output}
`);

                }

                lintAndTransform(input, options);

            }

            return false;

        });

    } else {

        lintAndTransform(input, options);

    }

} else {

    displayHelp();

}
