#!/usr/bin/env node

'use strict';

const fs = require('fs');

const chalk = require('chalk');

const spire = require('../lib/spire-of-babel');

const pkg = require('../package');

/**
* Displays help to stdout.
*/

const displayHelp = () => {

    process.stdout.write(`
${chalk.blue(' Usage:')} spire-of-babel <path> [options]

 Options:

${chalk.yellow('  -h, --help')}		Display this help message.
${chalk.yellow('  -v, --version')}		Display the current installed version.
${chalk.yellow('  -b, --bundle')}		Use browserify bundler.
${chalk.yellow('  -o, --output')}		Path to save transformed file to. Defaults to stdout.
${chalk.yellow('  -w, --watch')}		File path to watch for changes. Value must be in quotes. Example: "./test/**/*.jsx"
${chalk.yellow('  -s, --sourcemap')}	Generate sourcemap.

`);

};

/**
* Transforms input based on options passed to the command and outputs to either stdout or file.
*/

const transform = (input, options) => {

    spire.transformFile(input, options).then((result) => {

        if (options.output) {

            if (options.sourcemap) {

                fs.writeFile(options.output, result.code, 'utf8');
                fs.writeFile(`${options.output}.map`, result.map, 'utf8');

            } else {

                fs.writeFile(options.output, result.code, 'utf8');

            }

        } else {

            process.stdout.write(result.code);

        }

    })
    .catch((err) => {

        process.stderr.write(`${err}\n`);

    });

};

let input = null;

const options = {
    'bundle': false,
    'output': null,
    'watch': null,
    'sourcemap': false
};

const PROCESS_CMD_LINE_ARGS_LENGTH = 2;

const args = process.argv.slice(PROCESS_CMD_LINE_ARGS_LENGTH);

while (args.length) {

    const currentArg = args.shift();

    if (/^(?!\-).*/.test(currentArg)) {

        input = currentArg;

    } else {

        switch (currentArg) {

        case '-b':
        case '--bundle':

            options.bundle = true;

            break;

        case '-o':
        case '--output':

            options.output = args.shift();

            break;

        case '-w':
        case '--watch':

            options.watch = spire.parseWatchPath(args.shift());

            break;

        case '-s':
        case '--sourcemap':

            options.sourcemap = true;

            break;

        case '-v':
        case '--version':

            process.stdout.write(`${pkg.version}\n`);
            process.exit();

            break;

        default:

            displayHelp();
            process.exit();

            break;

        }

    }

}

if (input) {

    if (options.watch) {

        fs.watch(options.watch.directory, {
            'recursive': options.watch.recursive
        }, (event, filename) => {

            if (event === 'change' && filename.match(options.watch.filename)) {

                if (options.output) {

                    process.stdout.write(`
${chalk.gray('Change detected to: ')}${filename}
${chalk.green('Transformed: ')}${input} -> ${options.output}
`);

                }

                transform(input, options);

            }

        });

    } else {

        transform(input, options);

    }

} else {

    displayHelp();

}
